<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../polymer/lib/utils/debounce.html">
<link rel="import" href="../paper-autocomplete/paper-autocomplete.html">
<link rel="import" href="../fs-request/fs-request.html">

<dom-module id="fs-date">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="date" hidden$="[[edit]]">{{_displayDate(date)}}</div>
    <template is="dom-if" if="[[edit]]">
      <fs-request 
        id="request" 
        url="{{_computeUrl(date.original)}}"
        headers='{"Accept":"text/plain"}'
        on-response="_handleResponse"></fs-request>
      <paper-autocomplete 
        id="autocomplete" 
        label="[[label]]" 
        no-label-float="[[no-label-float]]"
        remote-source
        disabled="{{disabled}}"
        on-autocomplete-change="_autocompleteChange"
        on-autocomplete-selected="_autocompleteSelected"></paper-autocomplete>
    </template>
  </template>

  <script>
    /**
     * `fs-date`
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class FsDate extends Polymer.Element {
      
      static get is() { return 'fs-date'; }
      
      static get properties() {
        return {
          date: {
            type: Object,
            notify: true
          },
          
          label: {
            type: String,
            value: 'Date'
          },
          
          noLabelFloat: {
            type: Boolean,
            value: false
          },
          
          disabled: {
            type: Boolean,
            value: false
          },
          
          /* Toggle edit mode */
          edit: {
            type: Boolean,
            value: false,
            observer: '_setupEdit'
          },
          
          _debouncer: Object
        };
      }
      
      _displayDate(date) {
        if(!date) {
          return '';
        }
        return date.original || (date.normalized && date.normalized[0] ? date.normalized[0].value : false) || date.formal;
      }
      
      _setupEdit(edit) {
        // Have to defer this execution to give time for Polymer to stamp the
        // DOM since it's in a dom-if helper template
        if(edit) {
          setTimeout(() => {
            this.shadowRoot.querySelector('#autocomplete').text = this._displayDate(this.date);
            this.shadowRoot.querySelector('#autocomplete').value = JSON.stringify(this.date);
          });
        }
      }
      
      _computeUrl(original) {
        if(original) {
          return `/platform/dates?date=${original}`;
        }
      }
      
      _autocompleteChange(e) {
        if(e.detail && e.detail.text) {
          if(!this.date) {
            this.date = {};
          }
          this.set('date.original', e.detail.text);
          this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(300), () => { 
            this.shadowRoot.querySelector('#request').generateRequest(); 
          });
        }
      }
      
      _autocompleteSelected(e) {
        this.date = JSON.parse(e.detail.value);
      }
      
      _handleResponse(e) {
        const response = e.detail.response;
        if(response.statusCode === 200) {
          const value = {
            original: response.body,
            normalized: [{
              lang: response.headers['content-language'],
              value: response.body
            }],
            formal: response.headers.location ? response.headers.location.replace('gedcomx-date:', '') : undefined
          };
          this.shadowRoot.querySelector('#autocomplete').suggestions([
            {
              text: response.body,
              value: JSON.stringify(value)
            }
          ]);
        }
      }
    }

    window.customElements.define(FsDate.is, FsDate);
  </script>
</dom-module>
